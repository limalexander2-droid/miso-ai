/* ==============================
   SETTINGS
============================== */
const ENABLE_ANIM = false; // keep taps snappy

/* ==============================
   STATE + DOM REFERENCES
============================== */
let currentQuestion = 0;
let answers = [];

const container = document.getElementById("question-container");
const answerButtons = document.getElementById("answer-buttons");
const resultContainer = document.getElementById("result");
const loadingContainer = document.getElementById("loading");
const quizContainer = document.getElementById("quiz");

const loadingMessages = [
  { emoji: "üç£", text: "Plating your cravings‚Ä¶" },
  { emoji: "üçú", text: "Asking the kitchen for something special‚Ä¶" },
  { emoji: "ü•¢", text: "Warming up the noodles‚Ä¶" },
  { emoji: "üç±", text: "Tossing ideas into the wok‚Ä¶" },
  { emoji: "üå∂Ô∏è", text: "Sniffing out nearby bites‚Ä¶" },
  { emoji: "üß†", text: "Thinking with my stomach‚Ä¶" },
  { emoji: "ü•°", text: "Grabbing extra napkins‚Ä¶" },
  { emoji: "üßÇ", text: "Scouting the sauce section‚Ä¶" },
  { emoji: "üë®‚Äçüç≥", text: "Consulting my inner foodie‚Ä¶" }
];

/* ==============================
   QUESTION PROGRESS BAR
============================== */
function updateQuestionProgress() {
  const bar = document.getElementById("question-progress");
  if (!bar) return;
  const answered = currentQuestion;
  const total = questions.length || 1;
  const percent = Math.min(100, Math.round((answered / total) * 100));
  bar.style.width = `${percent}%`;
  bar.parentElement?.setAttribute("aria-valuenow", String(percent));
}

/* ==============================
   QUIZ QUESTIONS (upgraded)
============================== */
const questions = [
  { question: "When are you eating?", options: ["Now (0‚Äì30 min)", "Soon (30‚Äì90 min)", "Later (2‚Äì4 hrs)"] },
  { question: "How do you want to eat?", options: ["Dine-in", "Takeout", "Delivery", "Drive-thru", "No preference"] },
  { question: "How far will you go?", options: ["Walkable", "<10 min", "15‚Äì30 min", "I'll go anywhere"] },
  { question: "Budget per person?", options: ["$ (cheap)", "$$", "$$$", "$$$$"] },
  { question: "What sounds good right now?", options: ["Savory / Umami", "Fresh & light", "Spicy", "Comfort / Hearty", "Sweet / Dessert", "Seafood / Sushi", "Veg-forward"] },
  { question: "Any protein preference?", options: ["Chicken", "Beef", "Seafood", "Plant-based", "No preference"] },
  { question: "Any diet needs?", options: ["Vegan", "Vegetarian", "Gluten-free", "Low-carb / Keto", "High-protein", "No restrictions"] },
  { question: "Occasion or vibe?", options: ["Quick bite", "Casual hang", "Group-friendly", "Game on TV / Sports bar", "Date night", "Celebration / Upscale"] },
  { question: "Familiar vs adventurous?", options: ["Keep it classic", "Surprise me"] },
  { question: "Any extras you care about?", options: ["Patio", "Bar seating / TVs", "Quiet / low-noise", "Kid-friendly", "None"] }
];

/* ==============================
   MICRO-ANIMATIONS + TRANSITIONS
============================== */
function attachButtonEffects(parentEl = document) {
  if (!ENABLE_ANIM) return; // no-op for speed
  parentEl.querySelectorAll('button').forEach(btn => {
    btn.classList.add('tap-anim','ripple');
    btn.addEventListener('click', e => {
      const rect = btn.getBoundingClientRect();
      btn.style.setProperty('--ripple-x', (e.clientX - rect.left) + 'px');
      btn.style.setProperty('--ripple-y', (e.clientY - rect.top) + 'px');
      btn.classList.add('rippling');
      setTimeout(() => btn.classList.remove('rippling'), 250);
    });
  });
}

async function transitionQuestion(renderFn) {
  if (!ENABLE_ANIM) { renderFn(); return; }
  const q = document.getElementById('question-container');
  const head = document.getElementById('question-header');
  [q, head].forEach(node => node?.classList.remove('slide-in'));
  [q, head].forEach(node => node?.classList.add('slide-out'));
  await new Promise(r => setTimeout(r, 160)); // slightly faster
  renderFn();
  [q, head].forEach(node => node?.classList.remove('slide-out'));
  [q, head].forEach(node => node?.classList.add('slide-in'));
}

const emojiMap = [
  { match: /When are you eating\?/i, emoji: '‚è±Ô∏è' },
  { match: /How do you want to eat\?/i, emoji: 'üçΩÔ∏è' },
  { match: /How far will you go\?/i, emoji: 'üó∫Ô∏è' },
  { match: /Budget per person\?/i, emoji: 'üí∏' },
  { match: /What sounds good right now\?/i, emoji: 'üçî' },
  { match: /protein preference/i, emoji: 'üçó' },
  { match: /diet needs/i, emoji: 'ü•¶' },
  { match: /Occasion or vibe/i, emoji: '‚ú®' },
  { match: /Familiar vs adventurous/i, emoji: 'üß≠' },
  { match: /Any extras/i, emoji: 'üéõÔ∏è' },
];
function setQuestionEmoji(text) {
  const el = document.getElementById('question-emoji');
  const title = document.getElementById('question-title');
  const hit = emojiMap.find(e => e.match.test(text));
  if (el) el.textContent = hit ? hit.emoji : 'üçΩÔ∏è';
  if (title) title.textContent = text;
}

/* ==============================
   QUIZ FLOW
============================== */
function showQuestion() {
  resultContainer.classList.add("hidden");
  quizContainer.classList.remove("hidden");

  const progressIndicator = document.getElementById("progress-indicator");
  if (progressIndicator) progressIndicator.textContent = `Question ${currentQuestion + 1} of ${questions.length}`;

  const q = questions[currentQuestion];
  const render = () => {
    setQuestionEmoji(q.question);
    container.innerHTML = "";
    answerButtons.innerHTML = "";
    q.options.forEach(option => {
      const button = document.createElement("button");
      button.innerText = option;
      button.className = `
        bg-white text-gray-700 text-base px-5 py-4 rounded-2xl shadow-sm border border-gray-200
        hover:bg-gray-100 hover:text-slate-900 transition-all duration-150 ease-out
        focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-offset-2
      `;
      // pointerup fires faster than click on mobile; once prevents double-activation
      button.addEventListener("pointerup", () => selectAnswer(option), { once: true });
      answerButtons.appendChild(button);
    });
    attachButtonEffects(answerButtons);
  };

  transitionQuestion(render);
  updateQuestionProgress();
}

function selectAnswer(answer) {
  answers.push({ question: questions[currentQuestion].question, answer });
  currentQuestion += 1;
  updateQuestionProgress();

  if (currentQuestion < questions.length) {
    showQuestion();
  } else {
    showResults();
  }
}

/* ==============================
   RESULTS + LOADING
============================== */
function showResults() {
  const qBar = document.getElementById("question-progress");
  if (qBar) { qBar.style.transition = "width 200ms ease-out"; qBar.style.width = "100%"; qBar.parentElement?.setAttribute("aria-valuenow", "100"); }

  quizContainer.classList.add("hidden");
  const sound = document.getElementById("miso-sound");
  if (sound) sound.play().catch(() => {});
  loadingContainer.classList.remove("hidden");

  const progressBar = document.getElementById("progress-bar");
  if (progressBar) {
    progressBar.style.transition = "none"; progressBar.style.width = "0%"; void progressBar.offsetWidth;
    progressBar.style.transition = "width 2.2s ease-in-out"; progressBar.style.width = "100%";
  }

  const loadingText = loadingContainer.querySelector("p");
  const loadingEmoji = document.getElementById("loading-emoji");
  let messageIndex = 0;
  function updateLoadingMessage() {
    const { emoji, text } = loadingMessages[messageIndex];
    if (loadingText) loadingText.textContent = text;
    if (loadingEmoji) loadingEmoji.textContent = emoji;
    messageIndex = (messageIndex + 1) % loadingMessages.length;
  }
  updateLoadingMessage();
  window.messageInterval = setInterval(updateLoadingMessage, 800);

  setTimeout(async () => {
    if (window.messageInterval) { clearInterval(window.messageInterval); window.messageInterval = null; }
    loadingContainer.classList.add("hidden");
    resultContainer.classList.remove("hidden");
    await initYelpResults();
  }, 2200);
}

/* ==============================
   SMART TERM EXPANSION (keywords + Yelp categories)
============================== */
function expandedSearchTerms(rawTerms) {
  const TERM_BANK = {
    sweet: {
      keywords: ['dessert','ice cream','frozen yogurt','gelato','bakery','boba','milk tea'],
      categories: ['desserts','icecream','frozenyogurt','gelato','bakeries','bubbletea']
    },
    spicy: {
      keywords: ['spicy','sichuan','thai','indian','hot chicken'],
      categories: ['szechuan','thai','indpak']
    },
    noodles: {
      keywords: ['ramen','pho','udon','noodles'],
      categories: ['ramen','vietnamese','noodles']
    },
    healthy: {
      keywords: ['healthy','salad','poke','mediterranean','grill'],
      categories: ['salad','poke','mediterranean','healthmarkets']
    },
    breakfast: {
      keywords: ['breakfast','brunch','coffee','bakery'],
      categories: ['breakfast_brunch','cafes','coffee','bakeries']
    },
    bbq: {
      keywords: ['bbq','barbecue','smokehouse','brisket'],
      categories: ['bbq']
    },
    burgers: {
      keywords: ['burger','smashburger'],
      categories: ['burgers','tradamerican']
    },
    pizza: {
      keywords: ['pizza','slice'],
      categories: ['pizza']
    },
    tacos: {
      keywords: ['taco','taqueria'],
      categories: ['tacos','mexican']
    },
    seafood: {
      keywords: ['seafood','oyster','sushi','poke'],
      categories: ['seafood','sushi','poke']
    },
    comfort: {
      keywords: ['comfort food','chicken and waffles','meatloaf','mac and cheese'],
      categories: ['comfortfood','southern']
    },
    international: {
      keywords: ['international','global'],
      categories: ['thai','indpak','mexican','chinese','japanese','korean','mediterranean','italian','vietnamese']
    },
    vegetarian: { keywords: ['vegetarian'], categories: ['vegetarian'] },
    vegan: { keywords: ['vegan'], categories: ['vegan'] },
    'gluten free': { keywords: ['gluten free'], categories: ['gluten_free'] },
    keto: { keywords: ['keto'], categories: [] },
    protein: { keywords: ['protein bowls','grill'], categories: [] },
  };

  const kws = new Set();
  const cats = new Set();
  rawTerms.forEach(t => {
    const key = String(t).toLowerCase().trim();
    if (key) kws.add(key); // keep raw token
    Object.entries(TERM_BANK).forEach(([k, val]) => {
      if (key.includes(k)) {
        val.keywords.forEach(x => kws.add(x));
        val.categories.forEach(x => cats.add(x));
      }
    });
  });

  return {
    keywords: [...kws].slice(0, 8),
    categories: [...cats].slice(0, 8),
  };
}

/* ==============================
   MAP ANSWERS -> keywords + categories (upgraded)
============================== */
function mapAnswersToParams() {
  const get = (q) => answers.find(a => a.question.includes(q))?.answer || "";

  const when      = get("When are you eating?");
  const how       = get("How do you want to eat?");
  const far       = get("How far will you go?");
  const budget    = get("Budget per person?");
  const flavor    = get("What sounds good right now?");
  const protein   = get("Any protein preference?");
  const diet      = get("Any diet needs?");
  const vibe      = get("Occasion or vibe?");
  const explore   = get("Familiar vs adventurous?");
  const extras    = get("Any extras you care about?");

  // --- BASE CONTROLS ---
  const open_now = /Now/.test(when);

  let transactions = [];
  if (how === "Delivery") transactions = ["delivery"];
  else if (how === "Takeout") transactions = ["pickup"];
  // Drive-thru has no Yelp transaction; bias via terms.

  const radius =
    far === "Walkable"   ? 800  :
    far === "<10 min"    ? 3000 :
    far === "15‚Äì30 min"  ? 8000 :
                           16000;

  const price =
    budget === "$ (cheap)" ? "1" :
    budget === "$$"        ? "1,2" :
    budget === "$$$"       ? "2,3" :
    budget === "$$$$"      ? "1,2,3,4" : undefined;

  // --- SIGNAL PACKS ---
  const kws  = new Set();
  const cats = new Set();

  if (flavor === "Savory / Umami") { ["bbq","burgers","noodles"].forEach(c => cats.add(c)); kws.add("grill"); }
  if (flavor === "Fresh & light")   { ["healthy"].forEach(c => cats.add(c)); }
  if (flavor === "Spicy")           { ["thai","szechuan","indpak"].forEach(c => cats.add(c)); kws.add("spicy"); }
  if (flavor === "Comfort / Hearty"){ ["comfortfood","southern"].forEach(c => cats.add(c)); }
  if (flavor === "Sweet / Dessert") { ["desserts","icecream","frozenyogurt","gelato","bakeries"].forEach(c => cats.add(c)); }
  if (flavor === "Seafood / Sushi") { ["seafood","sushi"].forEach(c => cats.add(c)); }
  if (flavor === "Veg-forward")     { ["vegetarian","vegan"].forEach(c => cats.add(c)); }

  if (protein === "Chicken")      kws.add("chicken");
  if (protein === "Beef")         kws.add("steak");
  if (protein === "Seafood")      cats.add("seafood");
  if (protein === "Plant-based") { cats.add("vegan"); cats.add("vegetarian"); }

  if (diet === "Vegan")        cats.add("vegan");
  if (diet === "Vegetarian")   cats.add("vegetarian");
  if (diet === "Gluten-free")  cats.add("gluten_free");
  if (diet === "Low-carb / Keto") { kws.add("keto"); kws.add("bowl"); }
  if (diet === "High-protein") { kws.add("protein bowl"); kws.add("grill"); }

  if (vibe === "Quick bite") { kws.add("fast food"); kws.add("counter service"); }
  if (vibe === "Group-friendly") { kws.add("family style"); }
  if (vibe === "Game on TV / Sports bar") { kws.add("sports bar"); }
  if (vibe === "Date night") { kws.add("wine bar"); }
  if (vibe === "Celebration / Upscale") { kws.add("steakhouse"); }

  if (explore === "Keep it classic") { ["pizza","burgers","mexican"].forEach(t => kws.add(t)); }
  if (explore === "Surprise me")     { ["thai","indpak","korean","szechuan","japanese","vietnamese"].forEach(c => cats.add(c)); }

  if (extras === "Patio") kws.add("patio");
  if (extras === "Bar seating / TVs") kws.add("sports bar");
  if (extras === "Quiet / low-noise") kws.add("cafe");
  if (extras === "Kid-friendly") kws.add("kid friendly");

  if (how === "Drive-thru") { kws.add("drive thru"); cats.add("burgers"); }

  // Always include a safe default
  cats.add("restaurants");

  const { keywords, categories } = expandedSearchTerms([...cats, ...kws]);

  return { keywords, categories, price, radius, transactions, open_now };
}

/* ==============================
   RESULTS RENDERING
============================== */
function hoursOrCallLine(b) {
  if (b.has_hours) {
    if (b.open_status === "open") return "‚è∞ Open now";
    if (b.open_status === "closed") return "‚è∞ Closed now";
    return "‚è∞ Hours available";
  }
  if (b.phone) return `Hours not listed ‚Äî tap to call üìû`;
  return "Hours not listed";
}

function toggleWidenFab(show) {
  const fab = document.getElementById("try-radius-fab");
  if (!fab) return;
  fab.classList.toggle("hidden", !show);
}

function renderBusinesses(businesses = []) {
  const list = document.getElementById("results-list");
  list.innerHTML = "";

  // cap to 10 results
  businesses = (businesses || []).slice(0, 10);

  if (!businesses.length) {
    toggleWidenFab(true);
    list.innerHTML = `<div class="p-4 border border-gray-200 rounded-xl bg-white shadow-sm"><p class="text-gray-700 text-sm">No matching restaurants found. Try widening the distance or clearing price filters.</p></div>`;
    return;
  }

  toggleWidenFab(false);

  businesses.forEach((b, i) => {
    const miles = typeof b.distance === "number" ? (b.distance / 1609.34).toFixed(1) : "";
    const a = document.createElement("a");
    a.href = b.url || "#";
    a.target = "_blank";
    a.rel = "noopener noreferrer";
    a.className = "relative p-4 rounded-2xl border bg-white shadow-sm hover:shadow-md transition flex gap-4";
    a.innerHTML = `
      ${i === 0 ? `<div class="top-pick-badge">Top Pick</div>` : ""}
      <img src="${b.image_url || ""}" alt="${b.name}" class="w-28 h-20 object-cover rounded-lg bg-gray-100" onerror="this.style.display='none'"/>
      <div class="flex-1">
        <div class="flex items-center justify-between">
          <h3 class="text-lg font-semibold text-gray-900">${b.name}</h3>
          ${b.price ? `<span class="text-sm text-gray-600">üí≤ ${b.price}</span>` : ""}
        </div>
        <div class="text-sm text-gray-700 mt-1">
          ${b.rating ? `‚≠ê ${b.rating} ¬∑ ` : ""}${b.review_count ? `${b.review_count} reviews` : ""}
        </div>
        <div class="text-xs text-gray-600 mt-1">
          ${Array.isArray(b.categories) ? b.categories.join(", ") : ""}
        </div>
        <div class="text-xs text-gray-600 mt-1">
          üìç ${b.address || ""} ${miles ? ` ¬∑ ${miles} mi` : ""}
        </div>
        <div class="text-xs text-gray-700 mt-1">
          ${hoursOrCallLine(b)} ${b.phone ? `‚Ä¢ <a href="tel:${b.phone.replace(/[^\d+]/g,'')}" class="underline">Call</a>` : ""}
        </div>
      </div>
    `;
    if (i === 0) a.classList.add("ring-2","ring-yellow-400");
    list.appendChild(a);
  });
}

/* ==============================
   YELP INTEGRATION + CONTROLS
============================== */
let currentSort = "best_match";
let openNow = false;         // UI toggle; also set from quiz if "Now"
let currentRadius = 8000;
let lastGeo = null;
let lastLocation = null;
let baseParams = null;
let filterState = { highRated: false, budget: false, nearby: false };

function readFilters() {
  filterState.highRated = !!document.getElementById("filter-highrated")?.checked;
  filterState.budget = !!document.getElementById("filter-budget")?.checked;
  filterState.nearby = !!document.getElementById("filter-nearby")?.checked;
  return filterState;
}

// Block lodging-type businesses from results
function isHotelLike(b) {
  const rawCats = Array.isArray(b.categories) ? b.categories : [];
  const asText = rawCats
    .map(c => (typeof c === 'string' ? c : (c.alias || c.title || '')))
    .join(' , ')
    .toLowerCase();
  const name = (b.name || '').toLowerCase();

  // word boundaries to avoid false matches like "Cinnabon"
  const banned = /\b(hotel|motels?|hostels?|lodging|resorts?|bed\s*&\s*breakfast|b&b|guest\s*house|inns?)\b/;
  return banned.test(asText) || banned.test(name);
}

// True only if the business is currently open
function isActuallyOpen(b) {
  if (typeof b.open_status === "string") return b.open_status === "open"; // normalized by backend
  if (typeof b.is_open_now === "boolean") return b.is_open_now;          // fallback if provided
  if (b.hours && b.hours[0] && typeof b.hours[0].is_open_now === "boolean") return b.hours[0].is_open_now;
  // If we don't know, treat as closed when "Open now" is on
  return false;
}

function applyClientFilters(items) {
  let list = [...items];

  // remove hotels/inns
  list = list.filter(b => !isHotelLike(b));

  // enforce Open now strictly when toggled
  if (openNow) list = list.filter(isActuallyOpen);

  if (filterState.highRated) list = list.filter(b => (b.rating || 0) >= 4.5);
  if (filterState.budget)    list = list.filter(b => !b.price || b.price.length <= 2);

  return list;
}

async function callYelp(params) {
  const resp = await fetch('/.netlify/functions/yelp-search', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(params)
  });
  if (!resp.ok) {
    const txt = await resp.text().catch(() => "");
    throw new Error(`Search failed (${resp.status}): ${txt}`);
  }
  const data = await resp.json();
  return data.businesses || [];
}

/* ===== Multi-query helpers: build small valid queries and merge results ===== */
function uniqById(items) {
  const map = new Map();
  items.forEach(b => { if (b && b.id && !map.has(b.id)) map.set(b.id, b); });
  return [...map.values()];
}

// Build a few valid query variants (term OR categories per request)
function buildQuerySet(baseParams) {
  const qs = [];
  const kw = (baseParams.keywords || []).slice(0, 6);
  const catSet = new Set((baseParams.categories || []).slice(0, 5));
  catSet.add('restaurants'); // ensure we're only searching restaurant-like categories
  const catList = [...catSet];
  if (catList.length) qs.push({ categories: catList.join(",") });

  // 1) primary combined keyword term
  if (kw.length) qs.push({ term: kw.slice(0, 3).join(" ") });

  // 2) single-strong keywords
  kw.slice(0, 4).forEach(w => qs.push({ term: w }));

  // 3) generic fallback
  qs.push({ term: "restaurants" });

  // de-dup
  const seen = new Set();
  return qs.filter(q => {
    const k = q.term ? `t:${q.term}` : `c:${q.categories}`;
    if (seen.has(k)) return false;
    seen.add(k);
    return true;
  });
}

async function mergedSearch(base, querySet, targetCount = 20) {
  let all = [];
  for (const q of querySet) {
    const results = await callYelp({ ...base, ...q });
    if (results?.length) {
      all = uniqById(all.concat(results));
      if (all.length >= targetCount) break;
    }
  }
  // If still empty, relax once (open_now off + wider radius + broader terms)
  if (!all.length) {
    const relaxed = { ...base, open_now: false, radius: Math.min(32000, (base.radius || 8000) * 2) };
    const relaxedSet = [...querySet, { term: "food" }, { term: "dinner" }, { term: "lunch" }, { term: "dessert" }, { term: "ice cream" }];
    for (const q of relaxedSet) {
      const results = await callYelp({ ...relaxed, ...q });
      if (results?.length) {
        all = uniqById(all.concat(results));
        if (all.length >= targetCount) break;
      }
    }
  }
  return all;
}

/* Main search that uses the multi-query strategy */
async function doSearch(overrides = {}) {
  readFilters();

  const base = {
    sort_by: filterState.nearby ? "distance" : currentSort,
    open_now: openNow,
    radius: currentRadius,
    limit: 20,
    price: baseParams?.price,
    transactions: baseParams?.transactions,
    ...overrides
  };

  if (lastGeo) {
    base.latitude = lastGeo.latitude;
    base.longitude = lastGeo.longitude;
    delete base.location;
  } else if (lastLocation) {
    base.location = lastLocation;
    delete base.latitude; delete base.longitude;
  }

  const querySet = buildQuerySet(baseParams || { keywords: ['restaurants'], categories: [] });

  showSkeletons();
  try {
    const results = await mergedSearch(base, querySet, 20);
    const filtered = applyClientFilters(results);
    renderBusinesses(filtered);
    toggleWidenFab(!filtered.length);
  } catch (e) {
    const list = document.getElementById("results-list");
    list.innerHTML = `<div class="p-4 border rounded-2xl bg-white text-sm text-red-600">Error: ${e.message}</div>`;
    toggleWidenFab(true);
  }
}

function showSkeletons() {
  const list = document.getElementById("results-list");
  list.innerHTML = "";
  for (let i = 0; i < 6; i++) {
    const card = document.createElement("div");
    card.className = "p-4 rounded-2xl border bg-white shadow-sm flex gap-4";
    card.innerHTML = `
      <div class="w-28 h-20 rounded-lg skeleton"></div>
      <div class="flex-1 space-y-2">
        <div class="h-4 w-2/3 rounded skeleton"></div>
        <div class="h-3 w-1/2 rounded skeleton"></div>
        <div class="h-3 w-1/3 rounded skeleton"></div>
      </div>`;
    list.appendChild(card);
  }
}

/* ==============================
   INIT RESULTS (controls + location + first fetch)
============================== */
async function initYelpResults() {
  // Controls
  const bestBtn = document.getElementById("sort-best");
  const ratingBtn = document.getElementById("sort-rating");
  const distanceBtn = document.getElementById("sort-distance");
  const openChk = document.getElementById("open-now");
  openNow = !!openChk?.checked; // sync initial UI state
  const widenBtn = document.getElementById("btn-widen");
  const widenFab = document.getElementById("try-radius-fab");
  const hiChk = document.getElementById("filter-highrated");
  const budChk = document.getElementById("filter-budget");
  const nearChk = document.getElementById("filter-nearby");

  const setActive = (btn) => {
    [bestBtn, ratingBtn, distanceBtn].forEach(b => {
      if (!b) return;
      const isActive = b === btn;
      b.classList.toggle("active", isActive);
      b.setAttribute("aria-pressed", isActive ? "true" : "false");
    });
  };

  bestBtn?.addEventListener("click", () => { currentSort = "best_match"; setActive(bestBtn); doSearch(); });
  ratingBtn?.addEventListener("click", () => { currentSort = "rating"; setActive(ratingBtn); doSearch(); });
  distanceBtn?.addEventListener("click", () => { currentSort = "distance"; setActive(distanceBtn); doSearch(); });
  openChk?.addEventListener("change", () => { openNow = !!openChk.checked; doSearch(); });
  widenBtn?.addEventListener("click", () => { currentRadius = Math.min(32000, Math.round(currentRadius * 1.5)); doSearch(); });
  widenFab?.addEventListener("click", () => { currentRadius = Math.min(32000, Math.round(currentRadius * 1.5)); doSearch(); });
  hiChk?.addEventListener("change", () => doSearch());
  budChk?.addEventListener("change", () => doSearch());
  nearChk?.addEventListener("change", () => doSearch());

  // Base params from answers
  baseParams = mapAnswersToParams();

  // If quiz said "Now", force Open now on and reflect in UI
  if (baseParams.open_now) {
    openNow = true;
    if (openChk) openChk.checked = true;
  }

  // Try geolocation first
  const geo = await new Promise((resolve) => {
    if (!navigator.geolocation) return resolve(null);
    navigator.geolocation.getCurrentPosition(
      (pos) => resolve({ latitude: pos.coords.latitude, longitude: pos.coords.longitude }),
      () => resolve(null),
      { enableHighAccuracy: true, timeout: 6000 }
    );
  });

  if (geo) {
    lastGeo = geo;
    await doSearch();
    return;
  }

  // Manual fallback UI (results screen)
  const locBox = document.getElementById("location-fallback");
  locBox?.classList.remove("hidden");

  const manualInput = locBox ? locBox.querySelector("#manual-location") : null;
  const useBtn = locBox ? locBox.querySelector("#use-location-btn") : null;

  const triggerSearch = async () => {
    const value = (manualInput?.value || "").trim();
    if (!value) return;
    lastLocation = value;
    lastGeo = null;
    await doSearch();
  };

  useBtn?.addEventListener("click", triggerSearch);
  manualInput?.addEventListener("keydown", (ev) => { if (ev.key === "Enter") triggerSearch(); });
}

/* ==============================
   RESTART
============================== */
const restartBtn = document.getElementById("restart-btn");
if (restartBtn) {
  restartBtn.addEventListener("click", () => {
    window.scrollTo({ top: 0, behavior: "smooth" });
    currentQuestion = 0;
    answers = [];

    document.getElementById("question-progress")?.parentElement?.setAttribute("aria-valuenow", "0");
    document.getElementById("progress-bar")?.parentElement?.setAttribute("aria-valuenow", "0");

    const qBar = document.getElementById("question-progress");
    if (qBar) { qBar.style.transition = "none"; qBar.style.width = "0%"; void qBar.offsetWidth; qBar.style.transition = ""; }

    const lb = document.getElementById("progress-bar");
    if (lb) { lb.style.transition = "none"; lb.style.width = "0%"; void lb.offsetWidth; }

    resultContainer.classList.add("hidden");
    loadingContainer.classList.add("hidden");
    quizContainer.classList.remove("hidden");

    // Reset Yelp state
    currentSort = "best_match";
    openNow = false;
    currentRadius = 8000;
    lastGeo = null;
    lastLocation = null;
    baseParams = null;
    filterState = { highRated: false, budget: false, nearby: false };

    showQuestion();
    updateQuestionProgress();

    const progressIndicator = document.getElementById("progress-indicator");
    if (progressIndicator) progressIndicator.textContent = `Question 1 of ${questions.length}`;
  });
}

/* ==============================
   INIT
============================== */
showQuestion();
updateQuestionProgress();
attachButtonEffects();
